const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const holdCanvas = document.getElementById("holdCanvas");
const holdCtx = holdCanvas.getContext("2d");
const nextCanvas = document.getElementById("nextCanvas");
const nextCtx = nextCanvas.getContext("2d");

const COLS = 10, ROWS = 20;
let BLOCK_SIZE = 30;
canvas.width = COLS * BLOCK_SIZE;
canvas.height = ROWS * BLOCK_SIZE;

let paused = false; // Correction ajoutée ici

let currentTheme = "nature";
let currentColors = {};
const blockImages = {};

function loadBlockImages(themeName) {
  const useImages = (themeName === "nature" || themeName === "bubble");
  ['I', 'J', 'L', 'O', 'S', 'T', 'Z'].forEach(letter => {
    if (useImages) {
      const img = new Image();
      img.src = `../themes/${themeName}/${letter}.png`;
      blockImages[letter] = img;
    } else {
      blockImages[letter] = null;
    }
  });

  if (themeName === "neon") {
    currentColors = {
      I: "#00ffff", J: "#007bff", L: "#ff8800",
      O: "#ffff00", S: "#00ff00", T: "#ff00ff", Z: "#ff0033"
    };
  } else if (themeName === "nuit") {
    currentColors = {
      I: "#555", J: "#666", L: "#777",
      O: "#888", S: "#999", T: "#aaa", Z: "#bbb"
    };
  } else if (themeName === "retro") {
    currentColors = {
      I: "#ffcc00", J: "#ff9900", L: "#ff6600",
      O: "#cc3300", S: "#ff3300", T: "#cc0033", Z: "#990066"
    };
  } else {
    currentColors = {
      I: "#5cb85c", J: "#388e3c", L: "#7bb661",
      O: "#cddc39", S: "#a2d149", T: "#558b2f", Z: "#9ccc65"
    };
  }

  const canvasBg = getComputedStyle(document.documentElement).getPropertyValue('--canvas-bg').trim();
  if (canvasBg) {
    canvas.style.background = canvasBg;
  }

  currentTheme = themeName;
}

function changeTheme(themeName) {
  const themeStyle = document.getElementById('theme-style');
  themeStyle.href = `../themes/${themeName}.css`;
  setTimeout(() => loadBlockImages(themeName), 100);
}

function newPiece() {
  const PIECES = [
    [[1, 1, 1, 1]],
    [[1, 0, 0], [1, 1, 1]],
    [[0, 0, 1], [1, 1, 1]],
    [[1, 1], [1, 1]],
    [[0, 1, 1], [1, 1, 0]],
    [[0, 1, 0], [1, 1, 1]],
    [[1, 1, 0], [0, 1, 1]]
  ];
  const LETTERS = ['I', 'J', 'L', 'O', 'S', 'T', 'Z'];
  const id = Math.floor(Math.random() * PIECES.length);
  return {
    shape: PIECES[id],
    letter: LETTERS[id],
    x: Math.floor((COLS - PIECES[id][0].length) / 2),
    y: 0
  };
}

function drawBlock(ctx, x, y, letter, size = BLOCK_SIZE) {
  const img = blockImages[letter];
  if (img && img.complete && img.naturalWidth > 0) {
    ctx.drawImage(img, x * size, y * size, size, size);
  } else {
    ctx.fillStyle = currentColors[letter] || "#aaa";
    ctx.fillRect(x * size, y * size, size, size);

    if (currentTheme === "neon") {
      ctx.shadowColor = ctx.fillStyle;
      ctx.shadowBlur = 10;
    } else {
      ctx.shadowBlur = 0;
    }

    if (currentTheme !== "nuit") {
      ctx.strokeStyle = "#333";
      ctx.strokeRect(x * size, y * size, size, size);
    }
  }
}

function drawBoard() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  board.forEach((row, y) =>
    row.forEach((letter, x) => {
      if (letter) drawBlock(ctx, x, y, letter);
    })
  );

  if (currentPiece) {
    currentPiece.shape.forEach((row, dy) =>
      row.forEach((val, dx) => {
        if (val) drawBlock(ctx, currentPiece.x + dx, currentPiece.y + dy, currentPiece.letter);
      })
    );
  }

  drawNext();
  drawHold();
}

function drawNext() {
  nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
  if (nextPiece) {
    const offsetX = Math.floor((nextCanvas.width / BLOCK_SIZE - nextPiece.shape[0].length) / 2);
    const offsetY = Math.floor((nextCanvas.height / BLOCK_SIZE - nextPiece.shape.length) / 2);
    nextPiece.shape.forEach((row, dy) =>
      row.forEach((val, dx) => {
        if (val) drawBlock(nextCtx, offsetX + dx, offsetY + dy, nextPiece.letter, BLOCK_SIZE);
      })
    );
  }
}

function drawHold() {
  holdCtx.clearRect(0, 0, holdCanvas.width, holdCanvas.height);
  if (heldPiece) {
    const offsetX = Math.floor((holdCanvas.width / BLOCK_SIZE - heldPiece.shape[0].length) / 2);
    const offsetY = Math.floor((holdCanvas.height / BLOCK_SIZE - heldPiece.shape.length) / 2);
    heldPiece.shape.forEach((row, dy) =>
      row.forEach((val, dx) => {
        if (val) drawBlock(holdCtx, offsetX + dx, offsetY + dy, heldPiece.letter, BLOCK_SIZE);
      })
    );
  }
}

function movePiece(dir) {
  currentPiece.x += dir;
  if (collision(currentPiece)) {
    currentPiece.x -= dir;
  }
}

function rotatePiece() {
  const oldShape = currentPiece.shape;
  currentPiece.shape = oldShape[0].map((_, i) => oldShape.map(row => row[i])).reverse();
  if (collision(currentPiece)) {
    currentPiece.shape = oldShape;
  }
}

function collision(piece) {
  return piece.shape.some((row, dy) =>
    row.some((val, dx) => {
      if (!val) return false;
      const x = piece.x + dx;
      const y = piece.y + dy;
      return x < 0 || x >= COLS || y >= ROWS || (y >= 0 && board[y][x]);
    })
  );
}

function dropPiece() {
  currentPiece.y++;
  if (collision(currentPiece)) {
    currentPiece.y--;
    merge();
    newTurn();
    if (collision(currentPiece)) {
      endGame();
    }
  }
}

function merge() {
  currentPiece.shape.forEach((row, dy) =>
    row.forEach((val, dx) => {
      if (val) {
        const x = currentPiece.x + dx;
        const y = currentPiece.y + dy;
        if (y >= 0) board[y][x] = currentPiece.letter;
      }
    })
  );
  clearLines();
}

function clearLines() {
  let lines = 0;
  board = board.filter(row => {
    if (row.every(cell => cell !== "")) {
      lines++;
      return false;
    }
    return true;
  });
  while (board.length < ROWS) board.unshift(Array(COLS).fill(""));
  if (lines > 0) {
    score += lines * 100;
    document.getElementById("score").textContent = "Score : " + score;
    if (score > highscore) {
      highscore = score;
      localStorage.setItem("vblocks_highscore", highscore);
      document.getElementById("highscore").textContent = "Record : " + highscore;
    }
  }
}

function holdPiece() {
  if (holdUsed) return;
  if (!heldPiece) {
    heldPiece = { ...currentPiece };
    newTurn();
  } else {
    [heldPiece, currentPiece] = [{ ...currentPiece }, { ...heldPiece }];
  }
  holdUsed = true;
}

function newTurn() {
  currentPiece = nextPiece;
  nextPiece = newPiece();
  holdUsed = false;
}

function endGame() {
  alert("Temps écoulé !");
  window.location.reload();
}

let board = Array.from({ length: ROWS }, () => Array(COLS).fill(""));
let currentPiece = newPiece();
let nextPiece = newPiece();
let heldPiece = null;
let holdUsed = false;
let score = 0;
let highscore = localStorage.getItem("vblocks_highscore") || 0;

function update(time = 0) {
  if (!paused) {
    dropPiece();
    drawBoard();
  }
  requestAnimationFrame(update);
}

document.addEventListener("keydown", (e) => {
  if (paused) return;
  switch (e.key) {
    case "ArrowLeft": movePiece(-1); break;
    case "ArrowRight": movePiece(1); break;
    case "ArrowDown": dropPiece(); break;
    case "ArrowUp": rotatePiece(); break;
    case "c":
    case "C": holdPiece(); break;
  }
});

loadBlockImages(currentTheme);
update();
